package com.hiperbou.vm.minicvm

import com.hiperbou.vm.compiler.Compiler // Existing assembler
import com.hiperbou.vm.decompiler.CoreOpcodeInformation
import com.hiperbou.vm.decompiler.OpcodeInformationChain
import com.hiperbou.vm.minicvm.lexer.Lexer
import com.hiperbou.vm.minicvm.parser.Parser
import com.hiperbou.vm.minicvm.codegen.CodeGenerator
import com.hiperbou.vm.minicvm.lexer.LexerException
import com.hiperbou.vm.minicvm.parser.ParserException
import com.hiperbou.vm.minicvm.codegen.CodeGenException
import com.hiperbou.vm.plugin.print.PrintOpcodeInformation

class MiniCvmCompiler {

    //private val lexer = Lexer("") // Will be re-initialized with source
    //private val parser = Parser(emptyList()) // Will be re-initialized with tokens
    //private val codeGenerator = CodeGenerator()
    // Use OpcodeInformationChain to include PrintOpcode if needed,
    // otherwise, Compiler() uses CoreOpcodeInformation by default.
    // Let's include PrintOpcodeInformation in case the MiniCVM language might support a print statement later
    // or if generated assembly uses PRINT for debugging.
    private val assembler = Compiler(OpcodeInformationChain(CoreOpcodeInformation(), PrintOpcodeInformation()))

    /**
     * Compiles MiniCVM source code into bytecode.
     *
     * @param sourceCode The MiniCVM source code as a string.
     * @return An IntArray representing the compiled bytecode.
     * @throws LexerException if lexing fails.
     * @throws ParserException if parsing fails.
     * @throws CodeGenException if code generation fails.
     * @throws com.hiperbou.vm.compiler.CompilerException if assembly to bytecode fails.
     */
    fun compile(sourceCode: String): IntArray {
        // Step 1: Lexing
        val currentLexer = Lexer(sourceCode)
        val tokens = currentLexer.tokenize()
        val codeGenerator = CodeGenerator()

        // Step 2: Parsing
        val currentParser = Parser(tokens)
        val programNode = currentParser.parse()

        // Step 3: Code Generation (MiniCVM to Assembly)
        val assemblyCode = codeGenerator.generate(programNode)

        // Step 4: Assembling (Assembly to Bytecode)
        // The existing assembler throws its own exceptions if assembly is invalid.
        val bytecode = assembler.generateProgram(assemblyCode)

        // Step 5: Return Bytecode
        return bytecode
    }
}

// Example of how it might be used (conceptual, not part of this file)
/*
fun main() {
    val miniCvmSource = """
      int main() {
        int x = 10;
        // Example of a print statement if we decide to support it via a built-in function
        // print(x + 2); // This would require PRINT opcode and function definition
        return x + 30;
      }
    """
    val miniCvmCompiler = MiniCvmCompiler()
    try {
        println("Compiling MiniCVM source:\n$miniCvmSource")
        val bytecode = miniCvmCompiler.compile(miniCvmSource)
        println("Generated Bytecode: ${bytecode.joinToString(", ")}")

        // Here you would typically load the bytecode into the VirtualMachine
        // val vm = VirtualMachine(bytecode, programStackSize = 100, operandStackSize = 30)
        // val result = vm.run()
        // println("VM execution result: $result")

    } catch (e: LexerException) {
        System.err.println("Lexer Error: ${e.message}")
    } catch (e: ParserException) {
        System.err.println("Parser Error: ${e.message}")
    } catch (e: CodeGenException) {
        System.err.println("Code Generator Error: ${e.message}")
    } catch (e: com.hiperbou.vm.compiler.CompilerException) {
        System.err.println("Assembler Error: ${e.message}")
    } catch (e: Exception) {
        System.err.println("An unexpected error occurred: ${e.message}")
        e.printStackTrace()
    }
}
*/
